<html>

<head>
<title>Using the Simple ECMAScript Engine</title>
<style type="text/css"><!--
	body	 { background: white; color: black; }
	h1,h2,h3 { font-family: sans-serif; }
	h2, h3   { background: #f0f0f0; }
        table    { display: block; 
		   float: none;
		   position: relative; 
		   left: 10%; }
	table	 { border: thin solid black;
		   border-collapse: collapse;
		   }
	table th { background: #f0f0f0;
		   border-bottom: thin solid black; }
	table th, table td { 
		   border-right: thin solid black;
		 }
        td { padding-left: 1ex; padding-right: 1ex; }
	pre i    { color: blue; }
	pre b    { color: red; }
	ul.toc   { font-size: x-small; }
	code.js  { font-family: sans-serif; }
	p.misc	 { font-size: x-small; color: gray; }
// -->
</style>

</head>

<body>

<h1>Using the Simple ECMAScript Engine (SEE)</h1>

<p>
by David Leonard, 2003.
</p>

<p>
ECMAScript is a standardized language also known variously as JavaScript, 
JScript, and LiveScript. 
SEE is a library that provides a parser and runtime environment for this 
language.
It conforms to ECMAScript Edition 3, and to JavaScript 1.5, with
some compatibility switches for earlier versions of
JavaScript and Microsoft's JScript.
</p>

<p>
This documentation is intended for developers wishing to incorporate
SEE into their applications. It explains how you can use SEE to:
<ul>
 <li>	  manage multiple, separate ECMAScript runtime environments,
 <li>	  evaluate instances of user-supplied ECMAScript program text, and
 <li>	  expose your application's objects to those programs.
</ul>
</p>

<p>
I will use the phrase "host application" to mean your application, or
any application that uses the SEE runtime environment as auxillary to
some primary purpose.
Typical examples of host applications are web browsers and
scripted XML processors.
</p>

<p>
Throughout this documentation, references are made to the C functions and
macros provided by the SEE library. To avoid definitional redundancy and 
to improve precision, the reader is encouraged to examine the SEE header 
files to find the precise definitions and arguments of each function or macro.
</p>

<h2 id="toc">Table of contents</h2>

<ul class="toc">
<li><a href="#req">1 Requirements</a>
<li><a href="#interp">2 Creating interpreters</a>
<li><a href="#mem">3 Memory management</a>
 <ul>
 <li><a href="#mem2">3.1 On memory allocators</a>
 </ul>
<li><a href="#eval">4 Running programs</a>
 <ul>
 <li><a href="#input">4.1 Inputs</a>
 <li><a href="#try">4.2 Try-catch contexts</a>
 </ul>
<li><a href="#value">5 Values</a>
 <ul>
 <li><a href="#conversion">5.1 Value conversion</a>
 <li><a href="#undef">5.2 Undefined, null, boolean and number values</a>
 <li><a href="#string">5.3 String values</a>
 </ul>
<li><a href="#object">6 Objects</a>
 <ul>
 <li><a href="#objclient">6.1 Object values, and the object client interface</a>
 <li><a href="#enum">6.2 Property enumerators</a>
 <li><a href="#objimpl">6.3 The object implementation interface</a>
 <li><a href="#native">6.4 Native objects</a>
 <li><a href="#cfunction">6.5 C function objects</a>
 <li><a href="#function">6.6 User function objects</a>
 <li><a href="#error">6.7 Errors and Error objects</a>
 </ul>
 <li><a href="#debug">7 Debugging facilities</a>
 <li><a href="#ref">References</a>
</ul>

<h2 id="req">1 Requirements</h2>

<p>
SEE is written completely in ANSI C.
Although SEE is essentially self-contained, it does depend on you
(the host application developer) providing the following:
<ul>
 <li> <strong>an IEEE 754 floating point type</strong> 
      Most modern compilers have this, but if you are developing
      for some old, obscure architecture, you should check.
 <li> <strong>a garbage-collecting memory allocator</strong>
      The free <a href="#ref-boehm">Boehm gc</a> is highly recommended
      (See also <a href="#mem">&sect;3.1</a>).
</ul>
</p>

<p>
At install time, SEE uses GNU configure to determine if these
are available, and also to determine other system-dependent
properties. 
Host applications should <code>#include &lt;see/see.h&gt;</code> to
access all the macros and functions prototypes.
</p>

<p>
(As a developer you may find the need to edit the header and configure
files to make SEE compile on your system. I would be interested in hearing what
changes were needed so that future releases can supply this automatically
for other users. Please send mail to <a href="mailto:leonard&#64;users.sourceforge.net.nospam">leonard&#64;users.sourceforge.net.nospam</a>.)
</p>

<h2 id="interp">2 Creating interpreters</h2>

<p>
The first step in executing ECMAScript program text with SEE is to create
yourself an <em>interpreter</em> instance. 
First, allocate storage for a 
<code>struct SEE_interpreter</code> and then call
<code>SEE_interpreter_init()</code> to initialise it.
</p>

<pre>
	struct SEE_interpreter interp_storage;

	SEE_interpreter_init(&interp_storage);
</pre>

<p>
A pointer to your initialised <code>SEE_interpreter</code> structure 
is required for almost every function that SEE provides. 
</p>

<p>
SEE supports multiple independent interpreter instances.
For example, in an HTML web browser application, each window may
need its own interpreter instance because the variables
and bindings to built-in objects can be different and separate in each one.
</p>

<p>
SEE's functions are not thread-safe,
but multiple interpreters can be run in separate threads.
Interpreters will remain
completely independent of each other if you
<ul>
<li>never pass an object or mutable string reference from one interpreter 
    to the other, and
<li>use a thread-safe (or interpreter-dependent) memory allocator.
</ul>
</p>

<p>
There is no mechanism for explicitly destroying an initialised
interpreter; instead, SEE relies on the garbage collector to reclaim all
unreferenced storage. If you want finalization semantics, you will
need to arrange that yourself.
</p>

<p>
If SEE encounters an internal error (such as memory exhaustion,
memory corruption, or a bug), it calls the function pointer
<code>SEE_abort</code>, 
passing it a pointer to the interpreter in context. The <code>SEE_abort</code>
global variable initially points to a wapper function that simply calls 
the C library function <code>abort()</code>. You can set the global variable
early if you want to handle errors more gracefully.
</p>

<pre>
 void (*SEE_abort)(struct SEE_interpreter *);
</pre>

<h2 id="mem">3 Memory management</h2>

<p>
SEE expects a garbage collecting memory allocator.
It is strongly recommended that the host application use the same memory 
management as SEE. SEE provides 'hook' function pointers that the host 
application can initialise for this purpose. These pointers must be set up 
before any interpreter instances are created.
</p>

<p>
SEE manages memory by calling through the following function pointers,
that you can change:
</p>

<pre>
 void* (*SEE_mem_malloc_hook)(struct SEE_interpreter *, unsigned int);
 void  (*SEE_mem_free_hook)(struct SEE_interpreter *, void *);
 void  (*SEE_mem_exhausted_hook)(struct SEE_interpreter *);
</pre>

<p>
If SEE was compiled with Boehm-gc support, these hooks are initialised to
wrappers around the <code>GC_malloc()</code> and 
<code>GC_free()</code> functions. 
Otherwise, they are <code>NULL</code> and your application must 
initialise them.
</p>

<p>
If you intend to implement your own allocator, be aware that all of
these hooks may be called with a NULL argument, indicating unknown context.
They must not throw exceptions.
</p>

<p>
If SEE detects a memory allocation function returning NULL, it will 
interpret this as an out-of-memory condition and call the
function pointer <code>SEE_mem_exhausted_hook</code>. It defaults 
to a function that simply calls <code>SEE_abort</code>. 
Your application may prefer to handle this more gracefully.
</p>

<p>
Currently, SEE never calls <code>SEE_mem_free_hook</code>,
although future versions may use it.
It may be safely left at its default value, NULL.
</p>

<p>
Three convenient macros allocate storage. They are:
<ul>
<li><code>SEE_NEW(interp, type)</code> 
	- allocate structure storage returning a pointer of type 
		<code>type *</code>
<li><code>SEE_NEW_ARRAY(interp, type, length)</code>
	- allocate array storage returning a pointer of type 
		<code>type *</code>
<li><code>SEE_ALLOCA(length, type)</code>
	- allocate an array of element storage on the stack returning a 
	  pointer of type <code>type *</code>
</ul>
It is worth familiarizing yourself with the macro definitions to
see what they do.
</p>

<h3 id="mem2">3.1 On memory allocators</h3>

<p>
Why is SEE so dependent on a garbage collector?
Why doesn't it use reference counting?
</p>

<p>
I justify SEE's reliance on a garbage collector with the following:
<ul>
<li> Using an alternative
(strict) memory allocator would have significantly increased the
development time, run-time performance and code size of the library,
and so too that of the host application. 
<li> Exceptions (<a href="#try">&sect;4.2</a>)
could not have been implemented easily with
<code>longjmp()</code>, because references on the stack would be lost.
<li> The object-prototype model of ECMAScript results in plenty of
circular references between constructor functions and instances,
and with recursive function scope chains.
A reference counting scheme would leak these.
<li> Decent garbage collectors for C are freely available (and some
good commercial ones exist, too).
</ul>
</p>

<h2 id="eval">4 Running programs</h2>

<p>
You should execute ECMAScript program text using the following general
strategy:
<ol>
 <li> obtain a reference to an (initialised) <code>SEE_interpreter</code>
	(<a href="#interp">&sect;2</a>);
 <li> construct a <code>SEE_input</code> unicode character stream to 
      transport the 
      ECMAScript program text to SEE
	(<a href="#input">&sect;4.1</a>);
 <li> establish a try-catch context
	(<a href="#try">&sect;4.2</a>);
 <li> call the function <code>SEE_Global_eval()</code> to parse and
      evaluate the stream;
 <li> handle any exceptions caught in the try-catch context
	(<a href="#try">&sect;4.2</a>);
 <li> optionally examine the value result returned
	(<a href="#value">&sect;5</a>);
</ol>
</p>

<p>
The <code>SEE_Global_eval()</code> function is optionally able to
return the value associated with the last statement executed. 
In a non-interactive environment, this value is meaningless, and the
value result return pointer given to <code>SEE_Global_eval()</code> may be 
safely given as NULL.
</p>

<pre>
  void SEE_Global_eval(struct SEE_interpreter *interp, 
                       struct SEE_input *input, 
                       struct SEE_value *res);
</pre>

<h3 id="input">4.1 Inputs</h3>

<p>
SEE uses character stream sources known as 'inputs' to scan and 
parse ECMAScript 
program text. Because the ECMAScript language makes extensive use of Unicode,
the inputs are a stream of type <code>SEE_unicode_t</code> UCS-4-encoded 
characters.
</p>

<p>
Three constructors for demonstration/testing different kinds of input stream
are provided. When called, they each create a new <code>SEE_input</code> 
structure, initialised and ready.
They are:
<ul>
  <li>	<code>SEE_input_file()</code>
	- reads from a stdio <code>FILE</code> pointer; understands BOMs
  <li>	<code>SEE_input_utf8()</code>
	- reads from a null-terminated <code>char</code> array;
	  assumes ASCII/UTF-8 encoding
  <li>	<code>SEE_input_string()</code>
	- reads from a <code>SEE_string</code>; assumes UTF-16 encoding
</ul>
</p>

<pre>
  struct SEE_input *SEE_input_file(struct SEE_interpreter *i, 
			FILE *f, const char *filename, const char *encoding);
  struct SEE_input *SEE_input_string(struct SEE_interpreter *i,
			struct SEE_string *s);
  struct SEE_input *SEE_input_utf8(struct SEE_interpreter *i, const char *s);
</pre>

<p>
If these constructors do not meet your needs, you
are encouraged to develop your own.
The rest of this section describes the input API in detail.
</p>

<p>
If you don't particularly care about Unicode, it is helpful to 
know that 7-bit ASCII is a direct subset of Unicode, so you can just cast 
each of your <code>char</code>s to a <code>SEE_unicode_t</code>. 
</p>

<p>
Why streams instead of strings?
SEE uses a stream API for inputs rather than (say) a 
simple UCS-4 or UTF-8 string API, because Unicode-compliant applications will 
usually have a much better understanding of the encodings they are using 
than will SEE. With only a small amount of effort, streams provide this 
flexibility while avoiding unnecessary duplication or translation of text
storage.
</p>

<p>
Inputs are described by <code>struct SEE_input</code> structures. 
These are functionally similar to stdio's <code>FILE</code> type, or Java's 
<code>ByteReader</code> classes. They stream fully-decoded Unicode characters.
The <code>SEE_input</code> structure maintains
the input's stream state and provides a pointer to its access methods.
</p>

<pre>
        struct SEE_input {
                struct SEE_inputclass *inputclass;
                SEE_boolean_t          eof;
                SEE_unicode_t          lookahead;
                ....
        };

	struct SEE_inputclass {
		SEE_unicode_t   (*next)(struct SEE_input *);
		void            (*close)(struct SEE_input *);
	};
</pre>

<p>
The <code>inputclass</code> member
indicates the access methods.
It is a pointer to a <code>SEE_inputclass</code> structure. This class structure
contains function pointers to the two methods <code>next()</code> and 
<code>close()</code>.
</p>

<p>Use these convenience macros to call the input methods:</p>

<table>
<thead>
<tr><th>Macro</th>
    <th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>SEE_INPUT_NEXT()</code></td>
    <td>consume and return the next Unicode character from the stream</td></tr>
<tr><td><code>SEE_INPUT_CLOSE()</code></td>
    <td>release any resources obtained by the stream</td></tr>
</tbody>
</table>


<p>
The <code>next()</code> method should advance the input pointer, update the
<code>eof</code> and <code>lookahead</code> members of the 
<code>SEE_input</code> structure, and return the old value of 
<code>lookahead</code>. 
SEE's scanner calls <code>next()</code> repeatedly, until
the <code>eof</code> member becomes true.
</p>

<p>
If the <code>next()</code> method encounters an encoding error, it should 
return <code>SEE_INPUT_BADCHAR</code> and try to recover. 
It can throw an exception if it wants to, but SEE does not attempt to 
handle that: the application or user program will receive it.
</p>

<p>
The <code>close()</code> method should deallocate any operating system
resources acquired during the input stream's construction. Note that,
by convention, SEE will not call the <code>close()</code> method 
of any application-supplied input. The onus is on the caller to close the
inputs supplied to SEE library functions.
</p>

<p>
The <code>SEE_input</code> structure represents the current state of the
input stream.
Most importantly, the <code>lookahead</code> field must always reflect the
next character that a call to <code>next()</code> would return.
Once initialised, the <code>filename</code>, <code>first_lineno</code> and 
<code>interpreter</code> members of the <code>SEE_input</code> structure 
should not be changed. 
The <code>lookahead</code> and <code>eof</code> members 
should also be initialised before the structure is given to SEE.
</p>

<p>
You are encouraged to read the source code to the three constructors
listed at the beginning of this section.
</p>


<h3 id="try">4.2 Try-catch contexts</h3>

<p>
SEE's exceptions are implemented using C's 
<code>setjmp()</code>/<code>longjmp()</code> mechanism. SEE provides macros 
that establish a try-catch context, and test later if a try block 
terminated abnormally (i.e. due to an thrown exception). Typical code that
uses try-catch looks like this:
</p>

<pre>
	struct SEE_interpreter *interp;
	struct SEE_value *e;
	<b>SEE_try_context_t</b> c; /* <i>storage for the try-catch context</i> */

	...

	<b>SEE_TRY</b>(interp, c) {

		/*
		 * <i>Now inside a protected "try block".</i>
		 * <i>The following calls may throw exceptions if they want,</i>
		 * <i>causing the try block to exit immediately.</i>
		 */
		do_something();
		do_something_else();

		/* 
		 * <i>Because the SEE_TRY macro expands into a 'for' loop,</i>
		 * <i>avoid using 'break', or 'return' statements.</i>
		 * <i>If you must leave the try block, use 'continue;',</i>
		 * <i>or throw an exception.</i>
		 */
	}

	/* <i>Code placed here always runs.</i> */
	do_cleanup();

	if ((e = <b>SEE_CAUGHT</b>(c))) {
		/* <i>Handle the thrown exception 'e', somehow.</i> */
		handle_exception(e);

		/* <i>or you can throw it up to the next try-catch like so:</i> */
		<b>SEE_THROW</b>(interp, e);
	}

	...
</pre>

<p>
Do <strong>not</strong> <code>return</code>, <code>goto</code> or 
<code>break</code> out of a try block; the macro does not check for this, 
and the try-catch context may not be restored properly, causing all sorts of
havoc.
</p>

<p>
Exceptions thrown outside of any try-catch context will cause the
interpreter to abort.
</p>

<p>
If you are not interested in catching exceptions, and only want the
'finally' behaviour, use the following idiom:
</p>

<pre>
	<b>SEE_TRY</b>(interp, c) {
		do_something();
	}
	do_cleanup();
	<b>SEE_DEFAULT_CATCH</b>(interp, c);
</pre>

<h2 id="value">5 Values</h2>

<p>
Eventually, the host application will need to pass numbers, strings and 
complex value objects about through the SEE interpreter to and from the user
code.
The ECMAScript language provides for only six value types. They are:
<ul>
 <li><em>undefined</em>	- with exactly one value: <code class=js>undefined</code>
 <li><em>null</em>	- with exactly one value: <code class=js>null</code>
 <li><em>boolean</em>	- with exactly two values: <code class=js>true</code>
			  and <code class=js>false</code>
 <li><em>number</em>	- IEEE 754 64-bit floating point numbers
 <li><em>string</em>	- UTF-16 character arrays of arbitrary length
 <li><em>object</em>	- a reference to a bag of named properties
</ul>
</p>

<p>
The <code>struct SEE_value</code> can represent values of all of
these types.
</p>

<pre>
	struct SEE_value {
	    enum { ... } 	    type;
	    union {
		SEE_boolean_t	    boolean;
		SEE_number_t	    number;
		struct SEE_string * string;
		struct SEE_object * object;
		...
	    } u;
	};
</pre>

<p>
The first member, <code>type</code>, acts as a discriminator,
and is usually one of 
<code>SEE_UNDEFINED</code>, <code>SEE_NULL</code>, 
<code>SEE_BOOLEAN</code>, <code>SEE_NUMBER</code>, <code>SEE_STRING</code> or
<code>SEE_OBJECT</code>.
</p>

<p>
Depending on the type,
you can access the corresponding value of a 
<code>struct SEE_value</code> (called <code>v</code>, say),
by accessing the correct field of its union member, <code>v.u</code>.
The following table shows which union fields are valid when:
</p>

<table>
<thead>
<tr>	<th><code>v.type</code></th>
	<th>Valid member</th>
	<th>Member's type</th>	</tr>
</thead>
<tbody>
<tr>	<td><code>SEE_UNDEFINED</code></td>
	<td>n/a</td>					</tr>
<tr>	<td><code>SEE_NULL</code></td>
	<td>n/a</td>					</tr>
<tr>	<td><code>SEE_BOOLEAN</code></td>
	<td><code>v.u.boolean</code></td>
	<td><code>SEE_boolean_t</code></td>		</tr>
<tr>	<td><code>SEE_NUMBER</code></td>
	<td><code>v.u.number</code></td>
	<td><code>SEE_number_t</code></td>		</tr>
<tr>	<td><code>SEE_STRING</code></td>
	<td><code>v.u.string</code></td>
	<td><code>struct SEE_string *</code></td>	</tr>
<tr>	<td><code>SEE_OBJECT</code></td>
	<td><code>v.u.object</code></td>
	<td><code>struct SEE_object *</code></td>	</tr>
</tbody></table>

<p>
Two other types (<code>SEE_COMPLETION</code> and <code>SEE_REFERENCE</code>)
are only used internally to SEE and are not documented here.
To coerce values into other types, use the utility functions
describe in <a href="#conversion">&sect;5.1</a>.
</p>

<p>
To create new values in <code>struct SEE_value</code> structures, 
use the following initialisation macros. They first set the <code>type</code> 
field and then copy the second parameter into the appropriate union field.
It is fine to use a local variable for a <code>struct SEE_value</code>,
because the garbage collector can see what is being used from the stack.
</p>

<pre>
	void SEE_SET_UNDEFINED(struct SEE_value *)
	void SEE_SET_NULL(struct SEE_value *)
	void SEE_SET_OBJECT(struct SEE_value *, struct SEE_object *)
	void SEE_SET_STRING(struct SEE_value *, struct SEE_string *)
	void SEE_SET_NUMBER(struct SEE_value *, SEE_number_t)
	void SEE_SET_BOOLEAN(struct SEE_value *, SEE_boolean_t)
</pre>

<p>
Avoid <em>storing</em> a <code>struct SEE_value</code> as a pointer.
Instead, extract and copy values into storage using the following macro:
</p>

<pre>
	void SEE_VALUE_COPY(struct SEE_value *dst, struct SEE_value *src)
</pre>

<p>
Most <code>SEE_value</code>s are passed about the SEE library functions using 
pointers. This is because the general contract is that the caller supplies
storage for the return value (usually named <code>ret</code>), while
other pointer arguments are treated as read-only.
Conventionally, the result value pointer is provided as the last argument 
to these functions and named <code>ret</code>.
<strong>Note</strong>:
The <code>SEE_VALUE_COPY()</code> macro breaks this convention
by instead following the better-known idiom of <code>memcpy()</code>, and
placing the destination first.
</p>

<h3 id="conversion">5.1 Value conversion</h3>

<p>
The ECMAScript language specification provides for conversion functions
that the host application developer may find useful. They convert arbitrary
values into values of a known type:

<ul>
<li><code>SEE_ToPrimitive()</code>
    - Returns a non-object value. It calls the
	object's <code>DefaultValue()</code> method
	(see <a href="#objimpl">&sect;6.3</a>)
<li><code>SEE_ToBoolean()</code>
    - Returns a value of type <code>SEE_BOOLEAN</code>
<li><code>SEE_ToNumber()</code>
    - Returns a value of type <code>SEE_NUMBER</code>
<li><code>SEE_ToInteger()</code>
    - Returns a value of type <code>SEE_NUMBER</code>
	that is also a finite integer
<li><code>SEE_ToString()</code>
    - Returns a value of type <code>SEE_STRING</code>
<li><code>SEE_ToObject()</code>
    - Returns a value of type <code>SEE_OBJECT</code>
	using the <code class=js>String</code>, 
	<code class=js>Number</code> and
	<code class=js>Boolean</code>
	constructors
</ul>
</p>

<pre>
  void SEE_ToPrimitive(struct SEE_interpreter *i, struct SEE_value *val, 
	struct SEE_value *hint, struct SEE_value *res);
  void SEE_ToBoolean(struct SEE_interpreter *i, struct SEE_value *val, 
	struct SEE_value *res);
  void SEE_ToNumber(struct SEE_interpreter *i, struct SEE_value *val,
	struct SEE_value *res);
  void SEE_ToInteger(struct SEE_interpreter *i, struct SEE_value *val,
	struct SEE_value *res);
  void SEE_ToString(struct SEE_interpreter *i, struct SEE_value *val,
	struct SEE_value *res);
  void SEE_ToObject(struct SEE_interpreter *i, struct SEE_value *val, 
	struct SEE_value *res);
</pre>

<h3 id="undef">5.2 Undefined, null, boolean and number values</h3>

<p>
The undefined and null types have exactly one implied value each, namely
<code class=js>undefined</code> and <code class=js>null</code>. 
(Note that <code class=js>null</code> is <em>not</em> an object type, and is
not related to C's <code>NULL</code> constant)
</p>

<p>
Boolean types (<code>SEE_boolean_t</code>) have values of either true (non-zero) or false (zero). 
</p>

<p>
Number values (<code>SEE_number_t</code>) are IEEE 754 signed floating 
point numbers, normally corresponding to the C compiler's built-in
<code>double</code> type.
</p>

<p>
The following macros may be used to find information about a number value.
(They assume that the <code>type</code> is <code>SEE_NUMBER</code>):
<ul>
  <li>	<code>SEE_NUMBER_ISNAN()</code>  - return true if the number is 
					   not finite or real
  <li>	<code>SEE_NUMBER_ISPINF()</code> - return true if number is +&infin;
  <li>	<code>SEE_NUMBER_ISNINF()</code> - return true if number is -&infin;
  <li>	<code>SEE_NUMBER_ISINF()</code>  - return true if number is 
					   &plusmn;&infin;
  <li>	<code>SEE_NUMBER_ISFINITE()</code> - number is not one of the above
</ul>
</p>

<p>
SEE also provides constants <code>SEE_Infinity</code> and <code>SEE_NaN</code>
which may be stored in number values, but should not be used to compare
number values. Use the macros mentioned previously, instead.
</p>

<p>
Numbers (and other values) may be converted to integers using the functions
<code>SEE_ToInt32()</code>, <code>SEE_ToUint32()</code> or 
<code>SEE_ToUint16()</code>. SEE provides three data types
for integers:
<ul>
  <li> <code>SEE_uint16_t</code>	- 16 bit unsigned integer
  <li> <code>SEE_uint32_t</code>	- 32 bit unsigned integer
  <li> <code>SEE_int32_t</code>		- 32 bit signed integer
</ul>
</p>

<h3 id="string">5.3 String values</h3>

<p>
String values are pointers to SEE_string structures, that hold UTF-16 strings.
Assuming a <code>struct SEE_string *</code> called <code>s</code>,
the useful members of this structure are shown in the following table:
</p>

<table>
<thead>
<tr><th>Member</th>
    <th>Member's type</th>
    <th>Description</th>		</tr>
</thead>
<tbody>
<tr><td><code>s->length</code></td>
    <td><code>unsigned int</code></td>
    <td>Length of string in UTF-16 characters</td> </tr>
<tr><td><code>s->data</code></td>
    <td><code>SEE_char_t *</code></td>
    <td>Read-only sring storage</td> </tr>
</tbody>
</table>

<p>
Be aware that other strings may come to share the string's data, such
as by forming substrings. 
A string's content must not be modified after construction because of this
risk. However, the <code>length</code>
field of a string may be changed to a <strong>smaller</strong> value
at any time without concern.
</p>

<p>
The <code>SEE_char_t</code> type represents each Unicode character in the
string.  It is equivalent to a 16-bit unsigned integer.
</p>

<p>
To manipulate a string, first create a new string using one of the following:
<ul>	
  <li><code>SEE_string_new()</code> - create a new, empty string
  <li><code>SEE_string_dup()</code> - create a new string with duplicate content
  <li><code>SEE_string_concat()</code> - create a new string by duplicating 
	two other strings
  <li><code>SEE_string_sprintf()</code> - create a new string using 
	<code>printf</code>-like arguments
  <li><code>SEE_string_vsprintf()</code> - create a new string using
	<code>vprintf</code>-like arguments
</ul>
</p>

<p>
And then, before passing your new string to any other function, append 
characters to it using the following:
<ul>
  <li><code>SEE_string_addch()</code> - append a UTF-16 character
  <li><code>SEE_string_append()</code> - append contents of another string
  <li><code>SEE_string_append_int()</code> - append a signed integer's
						representation in base 10
</ul>
</p>

<p>
Once a string has been passed to any other SEE function, it is generally
unwise to modify its contents in any way. It is also OK to share a string
between different interpreters if the string is guaranteed not to be
modified, and the garbage collector can cope with it.
</p>

<p>
All strings in SEE use UTF-16 encoding, meaning that in some cases
you may need to be aware of Unicode 'surrogate' characters. If the host
application really needs UCS-4 strings (which is subtly different to UTF-16),
you will need to write your own converter function. Use the implementation of 
<code>SEE_input_string()</code> (<a href="#input">&sect;4.1</a>) as 
the basis for such a converter.
</p>

<p>
Note: The <code>SEE_string_sprintf()</code> and
<code>SEE_string_vsprintf()</code> functions only generate Unicode
characters that lie in the 7-bit ASCII subset of Unicode.
</p>

<p>
Other string functions provided are:
<ul>
 <li><code>SEE_string_substr()</code> 
	- create a read-only substring string
 <li><code>SEE_string_literal()</code> 	
	- copy the string, quoting and escaping chars
 <li><code>SEE_string_fputs()</code> 	
	- put the string to the stdio file using UTF-8
 <li><code>SEE_string_cmp()</code> 	
	- compares two strings, like <code>strcmp()</code>
</ul>
</p>

<p>
If you find yourself comparing strings a lot, you may find it easier to
compare <em>internalised</em> strings. 
These are strings that are kept in a fast
hash table and may be compared equal using pointer equality. 
The <code>SEE_intern()</code> function is very fast on alread-interned strings,
so it is worth using over <code>SEE_string_cmp()</code> if the strings 
are likely to be intern'ed already. (Most property names are.)
</p>

<h2 id="object">6 Objects</h2>

<p>
ECMAScript uses a prototype-inheritance object model with simple named
properties. More information on the object model can be found in the 
<a href="#ref-ecma">ECMA-262 standard</a>, and in other JavaScript references.
</p>

<p>
Object instances are implemented as in-memory structures, with an 
<code>objectclass</code> pointer to a table of operational methods.
Object references are held inside values with a type field
of <code>SEE_OBJECT</code> (see <a href="#value">&sect;5</a>).
</p>

<p>
The following sections describes how in-memory objects can be accessed
and manipualated (the 'client interface'),
and also how host applications can expose their own application objects
and methods (the 'implementation interface').
</p>

<h3 id="objclient">6.1 Object values, and the object client interface</h3>

<p>
All object values are pointers to object instances.
The pointers are of type <code>struct SEE_object *</code>.
No object pointer in a <code>SEE_value</code> should ever point to
<code>NULL</code>.
It can be convenient to work with <code>struct SEE_object *</code> pointer 
types directly, instead of using <code>SEE_value</code>.
</p>

<p>
To use an existing object instance, you should interact with it using only the
following macros:
<ul>
<li><code>SEE_OBJECT_GET()</code>
	- retrieve a named property or return <code class=js>undefined</code>
	  ("<code class=js>o.prop</code>")
<li><code>SEE_OBJECT_PUT()</code>
	- create/update a named property
	  ("<code class=js>o.prop = val</code>")
<li><code>SEE_OBJECT_CANPUT()</code>
	- returns true if the property can be changed
<li><code>SEE_OBJECT_HASPROPERTY()</code>
	- tests for existence of a property
<li><code>SEE_OBJECT_DELETE()</code>
	- delete a property; returns true on success 
	  ("<code class=js>delete o.prop</code>")
<li><code>SEE_OBJECT_DEFAULTVALUE()</code>
	- returns the string or number value associated with the object
<li><code>SEE_OBJECT_CONSTRUCT()</code>
	- call object as a constructor ("<code class=js>new o(</code>...<code class=js>)</code>")
<li><code>SEE_OBJECT_CALL()</code>
	- call object as a function ("<code class=js>o(</code>...<code class=js>)</code>")
<li><code>SEE_OBJECT_HASINSTANCE()</code>
	- return true if the objects are related
	  ("<code class=js>x instanceof o</code>")
<li><code>SEE_OBJECT_ENUMERATOR()</code>
	- create a property enumerator ("<code class=js>for (i in o)</code> ...")
</ul>
</p>

<p>
<strong>Note:</strong>
The last four macros <strong>do not check</strong> if the object 
has a <code>NULL</code> pointer for the corresponding object method.
Calling them on an
unchecked object will probably result in an access violation (segmentation
fault). The following macros return true if the object safely provides 
those methods:
<ul>
 <li><code>SEE_OBJECT_HAS_CALL()</code>
 <li><code>SEE_OBJECT_HAS_CONSTRUCT()</code>
 <li><code>SEE_OBJECT_HAS_HASINSTANCE()</code>
 <li><code>SEE_OBJECT_HAS_ENUMERATOR()</code>
</ul>
</p>

<p>
When storing properties in an object with <code>SEE_OBJECT_PUT()</code>, 
a <code>flags</code> parameter is required. 
In normal operation, this flag should be supplied as zero, but when populating
an object with its properties for the first time, the following bit
flags can be used:
</p>

<table>
<thead>
<tr><th>Flag</th>
    <th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>SEE_ATTR_READONLY</code></td>
    <td>Future assignments (puts) on this property will fail</td></tr>
<tr><td><code>SEE_ATTR_DONTENUM</code></td>
    <td>Enumerators will not list this property<br>
	and will hide inherited prototype properties of<br>
	the same name (see <a href="#enum">&sect;6.2</a>)</td></tr>
<tr><td><code>SEE_ATTR_DONTDELETE</code></td>
    <td>Future <code class=js>delete</code>s on this property will 
	fail</td></tr>
</tbody>
</table>

<h2 id="enum">6.2 Property enumerators</h2>

<p>
A property enumerator is a mechanism for discovering the properties that
an object contains. The language exercises this with its
<code class=js>for (var v in ...)</code> construct.
The results of the enumeration need not be sorted, nor even
to be the same order each time. 
</p>

<p>
Calling <code>SEE_OBJECT_ENUMERATOR()</code> returns a 
newly created <i>enumerator</i> which is a pointer to a
<code>struct SEE_enum</code>.
Once obtained, the following macros can be used to access the enumerator:
<ul>
 <li><code>SEE_ENUM_NEXT()</code>
	- return a pointer to a property name string, or NULL 
          when the properties have been exhausted.
 <li><code>SEE_ENUM_RESET()</code>
	- rewind the enumerator to the start again
</ul>
</p>

<p>
Enumerators can assume that the underlying object does not change during
enumeration. 
A suggested strategy for a caller that does need to remove or add an object's
properties while enumerating them
is to first create a private list of its property names, ensuring that it
has exhausted the enumerator before attempting to modify the object.
</p>


<h3 id="objimpl">6.3 The object implementation interface</h3>

<p>
When a host application wishes to expose its own 'host objects' to 
ECMAScript programs, it must use the object implementation API
described in this section.
</p>

<p>
All SEE objects are in-memory structures starting with a 
<code>struct SEE_object</code>:
<pre>	
	struct SEE_object {
		struct SEE_objectclass *objectclass;
		struct SEE_object *     Prototype;
	};
</pre>

<p>
Normally, this structure is part of a larger structure that maintains the
object's private state. For example, native <code class=js>Number</code>
objects could be implemented with the following:
</p>

<pre>
	struct number_object {
		struct SEE_object object;
		SEE_number_t      number;
	};
</pre>

<p>
Keeping the <code>object</code> part at the top of the 
<code>number_object</code> structure means that pointers of type
<code>struct number_object *</code> can be cast to and from pointers of type
<code>struct SEE_object *</code>. This is a general idiom: begin all
host object structures with a field member of type
<code>struct SEE_object</code> named <code>object</code>.
</p>

<p>
Although the ECMAScript language does not use classes <i>per se</i>,
SEE's internal object implementation does use a class 'abstraction'
to speed up execution and make implementation re-use easier.
Each object has a field, <code>object.objectclass</code>, that must
be initialised to point to a <code>struct SEE_objectclass</code> that 
provides the object's behaviour. The class structure looks like this:
</p>

<pre>
	struct SEE_objectclass {
		struct SEE_string *     Class;		/* mandatory */
		SEE_get_fn_t            Get;		/* mandatory */
		SEE_put_fn_t            Put;		/* mandatory */
		SEE_boolean_fn_t        CanPut;		/* mandatory */
		SEE_boolean_fn_t        HasProperty;	/* mandatory */
		SEE_boolean_fn_t        Delete;		/* mandatory */
		SEE_default_fn_t        DefaultValue;	/* mandatory */
		SEE_enumerator_fn_t     enumerator;	/* optional */
		SEE_call_fn_t           Construct;	/* optional */
		SEE_call_fn_t           Call;		/* optional */
		SEE_hasinstance_fn_t    HasInstance;	/* optional */
	};
</pre>

<p>
The application generally provides this structure in static storage, as
most of its members are function pointers or strings known at compile time.
A member marked "optional" above may be set to <code>NULL</code>.
</p>

<p>
The mandatory object methods (<code>Get</code>, <code>Put</code>, etc.)
should provide the precise behaviours that SEE expects on native objects.
These behaviours are fully described in the 
ECMA-262 standard, but can be summarised in the following table:
</p>

<table>
<thead>
<tr><th>Method</th>
    <th>Behaviour</th></tr>
</thead>
<tbody>
<tr><td><code>Get</code></td>
    <td>retrieve a named property (or return <code class=js>undefined</code>)</td></tr>
<tr><td><code>Put</code></td>
    <td>create/update a named property</td></tr>
<tr><td><code>Delete</code></td>
    <td>delete a property or return 0</td></tr>
<tr><td><code>HasProperty</code></td>
    <td>returns 0 if the property doesn't exist</td></tr>
<tr><td><code>CanPut</code></td>
    <td>returns 0 if the property cannot be changed</td></tr>
<tr><td><code>DefaultValue</code></td>
    <td>turns the object into a string or number value</td></tr>
<tr><td><code>Construct</code></td>
    <td>constructs a new object; as per the
	<code class=js>new</code> keyword</td></tr>
<tr><td><code>Call</code></td>
    <td>the object has been called as a function</td></tr>
<tr><td><code>HasInstance</code></td>
    <td>returns 0 if the objects are unrelated</td></tr>
<tr><td><code>enumerator</code></td>
    <td>allow enumeration of the properties (see above)</td></tr>
</tbody>
</table>

<p>
It is up to the host application to provide storage for the properties, and
so forth. The simplest strategy is to ignore property calls to
<code>Put</code> and <code>Get</code> that are meaningless.
To this end, if the host object does not want to expend effort
supporting some of the mandatory operations, it can use the 
corresponding 'do-nothing' function(s) from this list:
<ul>
  <li><code>SEE_no_get()</code>
  <li><code>SEE_no_put()</code>
  <li><code>SEE_no_canput()</code>
  <li><code>SEE_no_hasproperty()</code>
  <li><code>SEE_no_delete()</code>
  <li><code>SEE_no_defaultvalue()</code>
  <li><code>SEE_no_enumerator()</code>
</ul>
</p>

<p>
The <code>Prototype</code> field of an object instance
can either be set to
<ul><li>the interpreter's <code>Object_prototype</code>, 
<li>to <code>NULL</code> (meaning no prototype), or 
<li>to some other object.</ul>
If you choose to use <code>NULL</code>, it is recommended you provide a 
<code class=js>toString()</code> method (to help with debugging).
</p>

<p>
Once the host application has constructed its own objects that
conform to the API, they can be inserted into the 'Global object'
as object-valued properties.
</p>

<p>
The 'Global object' is an unnamed, top-level object whose sole purpose
is to 'hold' all the built-in objects, such as <code class=js>Object</code>,
<code class=js>Function</code>, <code class=js>Math</code>,
etc., as well as all user-declared global variables. The host
application can access it through the <code>Global</code> member of the
<code>SEE_interpreter</code> structure.
</p>


<h3 id="native">6.4 Native objects</h3>

<p>
SEE provides support for a special kind of object class called <em>native 
objects</em>. Native objects maintain a hash table of properties, and 
implement the mandatory methods (plus <code>enumerator</code>), and 
correctly observe the <code>Prototype</code> field.
</p>

<pre>
	struct SEE_native {
		struct SEE_object       object;
		struct SEE_property *   properties[SEE_NATIVE_HASHLEN];
	};
</pre>

<p>
An application can create host objects based on native objects.
First, place a <code>struct SEE_native</code> at the beginning of a
structure:
</p>

<pre>
	struct some_host_object {
		struct SEE_native       native;
		int			host_specific_info;
	};
</pre>

<p>
Then, use the following objects methods, either directly in the 
<code>SEE_objectclass</code> structure, or by calling them indirectly 
from method implementations:
<ul>
  <li><code>SEE_native_get()</code>
  <li><code>SEE_native_put()</code>
  <li><code>SEE_native_canput()</code>
  <li><code>SEE_native_hasproperty()</code>
  <li><code>SEE_native_delete()</code>
  <li><code>SEE_native_defaultvalue()</code>
  <li><code>SEE_native_enumerator()</code>
</ul>
</p>


<h3 id="cfunction">6.5 C function objects</h3>

<p>
The host application will likely want a particular bit of C code to be able
to be called from the runtime environment.
To do this simply requires construction of a object whose 
<code>Prototype</code> field points to
<code class=js>Function.prototype</code>,
and whose <code>objectclass</code>'s <code>Call</code> method points to a 
C function that contains the desired code.
</p>

<p>
The function <code>SEE_cfunction_make()</code> performs this construction.
It takes a pointer to the C 
function, and an integer indicating the expected number of arguments. 
(The integer becomes the function object's
"<code class=js>length</code>" property.)
</p>

<pre>
  struct SEE_object *SEE_cfunction_make(struct SEE_interpreter *interp,
          SEE_call_fn_t func, struct SEE_string *name, int argc);
</pre>

<p>
NOTE: Objects returned by <code>SEE_cfunction_make()</code> should really only 
be used in the interpreter context in which they were created, but the 
current version of SEE does not check for this. (Because cfunction objects 
are essentially read-only after construction, and if memory allocation
operates independently of the interpreters, sharing cfunction objects 
across interpreters will be OK, but it is not recommended for future
portability.)
</p>

<p>
The C function must conform to the <code>SEE_call_fn_t</code> signature.
This is demonstrated below, with <code>math_sqrt()</code>, which is
the actual code behind the <code class=js>Math.sqrt</code> object:
</p>

<pre>
	static void
	math_sqrt(interp, self, thisobj, argc, argv, res)
		struct SEE_interpreter *interp;
		struct SEE_object *self, *thisobj;
		int argc;
		struct SEE_value **argv, *res;
	{
		struct SEE_value v;

		if (argc == 0)
			SEE_SET_UNDEFINED(res);
		else {
			SEE_ToNumber(interp, argv[0], &v);
			SEE_SET_NUMBER(res, sqrt(v.u.number));
		}
	}
</pre>

<p>
<!-- from <code>SEE_OBJECT_CALL</code> -->
The arguments to this function
are described in the following table:
</p>

<table>
<thead>
<tr><th>Argument</th>
    <th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>interp</code></td>
    <td>the current interpreter context</td></tr>
<tr><td><code>self</code></td>
    <td>a pointer to the object called 
	(<code class=js>Math.sqrt</code> here)</td></tr>
<tr><td><code>thisobj</code></td>
    <td>the <code class=js>this</code> object 
	(the <code class=js>Math</code> object in this 
	case)</td></tr>
<tr><td><code>argc</code></td>
    <td>number of arguments</td></tr>
<tr><td><code>argv</code></td>
    <td>array of value pointers, of length <code>argc</code></td></tr>
<tr><td><code>res</code></td>
    <td>uninitialised value location in which to store the result</td></tr>
</tbody>
</table>

<p>
A common convention in all ECMAScript functions is that unspecified
arguments should be treated as <code class=js>undefined</code>, and
extraneous arguments should just be ignored.
If the function uses <code>thisobj</code>, 
it should check any assumptions made about, especially if it is expected
to be a host object, because method functions can easily be attached to
other objects.
</p>


<h3 id="function">6.6 User function objects</h3>

<p>
Occasionally, a host application will wish to take some user text and 
create a callable function object from it. An example of this problem is 
in attaching the JavaScript code from HTML attributes onto form 
elements of a web page.
One way to achieve this is to invoke the <code class=js>Function</code> 
constructor object with the
<code>SEE_OBJECT_CONSTRUCT()</code> macro, passing it the formal arguments
text and body text as arguments.
(See <a href="#ref-ecma">the ECMAScript standard</a> for details on the
<code class=js>Function</code> constructor.)
</p>

<p>
Another way, that is more convenient if the user text is available as 
an input stream, is to use the <code>SEE_Function_new()</code> function:
</p>

<pre>
	struct SEE_object *SEE_Function_new(struct SEE_interpreter *interp, 
		struct SEE_string *name, struct SEE_input *param_input, 
		struct SEE_input *body_input);
</pre>

<p>
where any of the the <code>name</code>, <code>param_input</code> and
<code>body_input</code> parameters may be NULL (indicating to use the 
empty string).
</p>

<p>
The returned function object may be called with the 
<code>SEE_OBJECT_CALL()</code> macro.
</p>


<h3 id="error">6.7 Errors and Error objects</h3>

<p>
Host applications sometimes need to convey errors to ECMAScript programs.
Errors in ECMAScript are typically indicated by throwing an exception
with an object value.  The thrown objects conventionally have 
<code class=js>Error.prototype</code> somewhere in their prototype chain, 
and provide a <code class=js>message</code> and <code class=js>name</code> 
property which the <code class=js>Error.prototype</code> reads to generate
a human-readable error message.
</p>

<p>
Host applications can conveniently construct and throw error exceptions using 
the following macros:
</p>

<pre>
	void SEE_error_throw_string(struct SEE_interpreter *interp, 
		struct SEE_object *error_constructor,
		struct SEE_string *text);
	SEE_error_throw(struct SEE_interpreter *interp,
		struct SEE_object *error_constructor,
		const char *fmt, ...);
	SEE_error_throw_sys(struct SEE_interpreter *interp,
		struct SEE_object *error_constructor,
		const char *fmt, ...);
</pre>

<p>
These convenience macros construct a new error object, and throw it as an 
exception using <code>SEE_THROW()</code>.
The object thrown is given a <code class=js>message</code>
string property that reflects the rest of the arguments provided 
to the called macro.
The <code>SEE_error_throw_sys()</code> macro works like
<code>SEE_error_throw()</code> but appends a textual 
description of <code>errno</code> using <code>strerror()</code>.
</p>

<p>
The <code>error_constructor</code> argument should be one of the error 
constructor objects found in the <code>SEE_interpreter</code> structure:
</p>

<table>
<thead>
<tr><th>Member</th>
    <th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Error</code></td>
    <td>runtime error</td></tr>
<tr><td><code>EvalError</code></td>
    <td>error in <code class=js>eval()</code></td></tr>
<tr><td><code>RangeError</code></td>
    <td>numeric argument has exceeded allowable range</td></tr>
<tr><td><code>ReferenceError</code></td>
    <td>invalid reference was detected</td></tr>
<tr><td><code>SyntaxError</code></td>
    <td>parsing error</td></tr>
<tr><td><code>TypeError</code></td>
    <td>actual type of an operand different to that expected</td></tr>
<tr><td><code>URIError</code></td>
    <td>error in a global URI handling function</td></tr>
</tbody>
</table>

<p>
A simple example:
</p>

<pre>
     if (something_is_wrong)
	SEE_error_throw(interp, interp->Error, "something is wrong!");
</pre>

<p>
Although <code>Error</code> is usually sufficient for most errors,
host applications can create their own error constructor object with the
<code>SEE_Error_make()</code> convenience function. Only one constructor
of the same name should be created per interpreter.
</p>

<pre>
  struct SEE_object *SEE_Error_make(struct SEE_interpreter *interp,
                        struct SEE_string *name);
</pre>

<h2 id="debug">7 Debugging facilities</h2>

<p>
The SEE library contains various debugging facilities, that are
omitted if it is compiled with the <code>NDEBUG</code> preprocessor define.
</p>

<p>
Most useful to the application developer are these two functions:
</p>

<pre>
	void SEE_PrintValue(struct SEE_interpreter *i, 
		struct SEE_value *v, FILE *f);
	void SEE_PrintObject(struct SEE_interpreter *i, 
		struct SEE_object *o, FILE *f);
</pre>

<p>
If debugging the library itself, it is worth reading the source code to
find the debug flag variables that can be turned on by the host 
application to enable verbose traces during execution.
</p>

<h2 id="ref">References</h2>

<ul>
<li id="ref-ecma"><a href="http://ecma-international.org/publications/files/ecma-st/Ecma-262.pdf">ECMA-262, ECMAScript language specification</a>, 3rd edition, December 1999.
<li id="ref-boehm"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">The Boehm-Weiser garbage collection package for C and C++</a>
<li id="ref-utf16">Hoffman et al., <a href="http://www.ietf.org/rfc/rfc2781.txt">UTF-16, an encoding of ISO 10646</a> [RFC 2781], February 2000
</ul>

<hr>
<p class="misc">
&copy; David Leonard, 2003.
This documentation may be entirely reproduced and distributed in any form,
as long as this copyright notice remains intact, and the distributed
reproduction or translation is a complete and bona fide copy.
<br>
$Id$
</p>

</body>
</html>
