
SEE SHELL

This is an ECMAScript shell program used to test and demonstrate 
the SEE run-time library. It reads ECMAScript files and executes
them. It includes a simplistic 'HTML' mode where it will pre-process
a HTML document a little bit like a browser would. It also provides
an interactive (prompted) mode.


Usage
-----
	shell [-g] [-v] [-r <num>] [-d<debugflags>] [-c value] 
	      [-f file] [-h htmlfile] [-l library]

The '-g' option drops into the interactive debugger - see below for details.

The '-v' option prints the library version and API version used.

The '-r' option sets the function recursion limit. Default is -1 (indefinite).

The '-f file' and '-h htmlfile' options can be specified multiple times.
Each time they are specified, the given files are loaded and run.

The '-l library' flags must be specified before any -h or -f flags,
and load a library module. See below.

Files specified with -f are loaded and run as pure ECMAScript. The
entire file is parsed as a 'Program' (see the language grammar), and the
global statements are evaluated.  If an exception occurs during execution of
the file, it terminates the process (exit 1), otherwise processing continues.

Files specified with -h are loaded as HTML. The HTML content is copied to
stdout, except for text found inside <SCRIPT> elements. It is stripped and run
as ECMAScript (regardless of the LANGUAGE attribute).  Exceptions
are ignored in HTML files. (Lazy browser behaviour!) There is no support for
forms, URL inclusions or triggers such as 'onLoad'. It is very spartan.

If no -f or -h flags are given (or a "-f -" argument is given), an
interactive prompt is produced, and individual statements are read
from standard input until EOF.

The -c flag adds flags to the compatibility field of the interpreter.
Each occurrence of the -c flag bitwise-ors its integer argument into the
flag. The value may also be an identifier, optionally prefixed with 'no'.
These identifiers are documented in detail in USAGE.html:

    sgmlcom     - treat SGML comments in program text as normal comments
    utf_unsafe  - pass through invalid UTF-8 characters without error
    undefdef    - return undefined for unknown names instead of throwing
    262_3b      - provide the optional functions in section 3B of standard
    ext1        - enable local SEE extension set number 1


NOTE: The command line arguments were chosen to be compatible with
the perl script used with Mozilla/spidermonkey's test suite.

The debug flags for -d only make sense if you are debugging the engine,
although the trace option (-dT) can be useful. The flags are:

    -dE         - debug the error constructors
    -dT         - enable call tracing
    -dc         - debug context and symbol scope operations
    -de         - debug exception try/catch
    -dl         - debug the lexical analysis stage
    -dn         - debug the native object module interface
    -dp         - debug the parsing stage
    -dr         - debug regular expression processing
    -dv         - debug the evaluation stage


Shell-provided objects and functions
------------------------------------

Besides the standard environment required by ECMA-262,
the shell provides a couple of objects useful for testing.

 print       - a function which prints its argument string followed
               by a newline.
 version     - a Netscape-compatible compatibility setter/getter

XXX- tbd
 SEE.print   - same as print() above
 SEE.version - same as version() above
 SEE.compat  - changes/reports SEE compatibility flags
 SEE.load    - loads and runs another script file (see -f flag)

In HTML mode the following objects are provided:

 document            - a simple Object with some properties:
 document.write      - a function to print a string to stdout
 document.navigator  - a simple Object used as a placeholder
 document.userAgent  - "SEE-shell (see-1.0)" or similar
 document.window     - a reference to the Global object

Interactive debugger
--------------------

The simple interactive debugger demonstrates how the SEE library can be
controlled by a debugger via the trace() callback. The first time
ECMAScript code is excuted, the debugger provides a prompt to the
user. Command available at the prompt include:

	break [<filename>:]<lineno>	- add a new breakpoint
	show				- show current breakpoints
	delete <number>			- delete existing breakpoint

	step				- step to a new line
	cont				- continue execution

	where				- print traceback information
	info				- current context information
	eval <expr>			- evaluate expression in context
	throw <expr>			- throw an exception value

Dynamically loaded modules
--------------------------

The -l option which should be used before any -f or -h options dlopens a 
file and looks for an exported structure called 'module'. The structure 
should be of the form:

	struct SEE_module {
		SEE_uint32_t	magic;	/* SEE_IMPORT_MAGIC */
		const char *name;	/* name of module */
		const char *version;	/* module version */
		int (*modinit)(void);	/* called once on first load */
		void (*alloc)(struct SEE_interpreter *interp);
		void (*init)(struct SEE_interpreter *interp);
	};

The modinit() function should obtain global strings using SEE_intern() or
SEE_intern_ascii().  The init() function should insert module functions and
values into the interpreter->Global object. Usually, you will want to create
a toplevel 'container' object to hold your functions and constructors
(see, for example ECMAScript's Math object).

David Leonard

$Id$
